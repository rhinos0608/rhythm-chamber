---
phase: 09-key-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - js/security/encryption.js
autonomous: true

must_haves:
  truths:
    - PBKDF2 helper functions accept extractable parameter
    - Session key derivation uses unique per-session salt
    - Existing deriveKey() function is backward compatible
    - No breaking changes to existing encryption API
  artifacts:
    - path: js/security/encryption.js
      provides: PBKDF2 utilities with non-extractable support
      exports: ["deriveKey", "deriveKeyNonExtractable", "getSessionKey", "encryptData", "decryptData"]
  key_links:
    - from: deriveKeyNonExtractable()
      to: crypto.subtle.deriveKey
      via: Web Crypto API
      pattern: "crypto\\.subtle\\.deriveKey\\(.*extractable:\\s*false"
    - from: js/security/key-manager.js
      to: js/security/encryption.js
      via: ES6 import
      pattern: "import.*from.*encryption\\.js"
---

<objective>
Extend encryption.js with PBKDF2 utilities that support non-extractable key creation.

Purpose: Provide helper functions that KeyManager can use for key derivation. The existing deriveKey() already uses extractable: false but needs helper variants for different key types (data encryption, signing).
Output: Enhanced encryption.js with deriveKeyNonExtractable() and HMAC key derivation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/09-key-foundation/09-RESEARCH.md

@js/security/encryption.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add deriveKeyNonExtractable helper function</name>
  <files>js/security/encryption.js</files>
  <action>
Add a new helper function to js/security/encryption.js after the existing deriveKey() function (after line 112):

**deriveKeyNonExtractable(password, salt, keyType = 'aes-gcm')**
- Accepts password (string), salt (string), keyType (string)
- For keyType 'aes-gcm': Derive AES-GCM-256 key with ['encrypt', 'decrypt'] usage
- For keyType 'hmac': Derive HMAC-SHA-256 key with ['sign', 'verify'] usage
- Always use extractable: false
- Use 600,000 PBKDF2 iterations
- Return CryptoKey

Implementation:
```javascript
/**
 * Derive a non-extractable cryptographic key using PBKDF2
 * All keys created with this function cannot be exported from memory
 *
 * SECURITY: Keys are non-extractable - they cannot be exported via exportKey()
 * This satisfies KEY-01 requirement for non-extractable session keys
 *
 * @param {string} password - Password or token to derive from
 * @param {string} salt - Salt for key derivation (use unique per-session salt)
 * @param {string} keyType - Type of key: 'aes-gcm' for encryption, 'hmac' for signing
 * @returns {Promise<CryptoKey>} Non-extractable derived key
 */
async function deriveKeyNonExtractable(password, salt, keyType = 'aes-gcm') {
    const encoder = new TextEncoder();
    const keyMaterial = await crypto.subtle.importKey(
        'raw',
        encoder.encode(password),
        'PBKDF2',
        false, // Key material not extractable
        ['deriveKey']
    );

    if (keyType === 'hmac') {
        // Derive HMAC signing key
        return crypto.subtle.deriveKey(
            {
                name: 'PBKDF2',
                salt: encoder.encode(salt),
                iterations: 600000,
                hash: 'SHA-256'
            },
            keyMaterial,
            { name: 'HMAC', hash: 'SHA-256' },
            false, // NON-EXTRACTABLE
            ['sign', 'verify']
        );
    }

    // Default: AES-GCM encryption key
    return crypto.subtle.deriveKey(
        {
            name: 'PBKDF2',
            salt: encoder.encode(salt),
            iterations: 600000,
            hash: 'SHA-256'
        },
        keyMaterial,
        { name: 'AES-GCM', length: 256 },
        false, // NON-EXTRACTABLE
        ['encrypt', 'decrypt']
    );
}
```

Add to exports at the end of the file (in the export statement around line 271).
  </action>
  <verify>
  - deriveKeyNonExtractable() function exists
  - Function accepts password, salt, keyType parameters
  - Both deriveKey() calls use extractable: false
  - HMAC key derivation returns correct algorithm
  - Function is exported in module exports
  </verify>
  <done>
encryption.js now exports deriveKeyNonExtractable() that creates:
- AES-GCM-256 keys with ['encrypt', 'decrypt'] usage
- HMAC-SHA-256 keys with ['sign', 'verify'] usage
- All keys are non-extractable (extractable: false)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add generateSalt helper function</name>
  <files>js/security/encryption.js</files>
  <action>
Add a helper function for generating cryptographically secure random salts:

**generateSalt(length = 32)**
- Use crypto.getRandomValues() with Uint8Array
- Convert to hex string
- Return hex string of length * 2 characters

Add after generateRandomString() function (after line 21):

```javascript
/**
 * Generate a cryptographically secure random salt for key derivation
 * Uses crypto.getRandomValues() for cryptographic security
 *
 * @param {number} length - Number of random bytes (default 32)
 * @returns {string} Hex-encoded salt string
 */
function generateSalt(length = 32) {
    const saltBytes = crypto.getRandomValues(new Uint8Array(length));
    return Array.from(saltBytes, b => b.toString(16).padStart(2, '0')).join('');
}
```

Add to exports.
  </action>
  <verify>
  - generateSalt() function exists
  - Uses crypto.getRandomValues()
  - Returns hex string
  - Function is exported
  </verify>
  <done>
encryption.js now exports generateSalt() for creating unique per-session salts.
  </done>
</task>

</tasks>

<verification>
After completion, verify:
1. No breaking changes to existing API (deriveKey still works)
2. deriveKeyNonExtractable() is exported
3. generateSalt() is exported
4. All keys use extractable: false
5. HMAC variant correctly derives signing keys
</verification>

<success_criteria>
1. deriveKeyNonExtractable(password, salt, 'aes-gcm') returns AES-GCM key
2. deriveKeyNonExtractable(password, salt, 'hmac') returns HMAC key
3. generateSalt(32) returns 64-character hex string
4. All functions exported and accessible
</success_criteria>

<output>
After completion, create `.planning/phases/09-key-foundation/09-02-SUMMARY.md`
</output>

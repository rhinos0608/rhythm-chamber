---
phase: 14-crosstab-security
plan: 02
type: execute
wave: 2
depends_on: [14-01]
files_modified:
  - js/services/tab-coordination.js
autonomous: true
user_setup: []

must_haves:
  truths:
    - "All outgoing BroadcastChannel messages include HMAC signature"
    - "All outgoing BroadcastChannel messages include timestamp"
    - "All outgoing messages are sanitized to remove sensitive data"
    - "All incoming messages have HMAC signature verified before processing"
    - "All incoming messages have origin validated against window.location.origin"
    - "All incoming messages have timestamp validated (max 5 seconds old)"
    - "All incoming messages have nonce checked for replay prevention"
    - "Messages failing verification are rejected and logged"
  artifacts:
    - path: "js/services/tab-coordination.js"
      provides: "Secure cross-tab coordination with message signing"
      contains: ["signMessage(", "verifyMessage(", "validateTimestamp(", "sanitizeMessage("]
      exports: ["TabCoordinator"]
  key_links:
    - from: "sendMessage()"
      to: "Security.MessageSecurity.signMessage"
      via: "outgoing message signing"
      pattern: "signMessage.*coordinationTransport\\.postMessage"
    - from: "createMessageHandler()"
      to: "Security.MessageSecurity.verifyMessage"
      via: "incoming message verification"
      pattern: "verifyMessage.*before processing"
    - from: "createMessageHandler()"
      to: "window.location.origin"
      via: "origin validation"
      pattern: "message\\.origin.*window\\.location\\.origin"
    - from: "createMessageHandler()"
      to: "Security.MessageSecurity.validateTimestamp"
      via: "timestamp validation"
      pattern: "validateTimestamp.*message\\.timestamp"
    - from: "createMessageHandler()"
      to: "Security.MessageSecurity.isNonceUsed"
      via: "nonce replay check"
      pattern: "isNonceUsed.*message nonce"
---

# Phase 14 Plan 02: Integrate MessageSecurity into Tab Coordination

**Objective:** Integrate MessageSecurity module into the tab coordination service to secure all BroadcastChannel communications with HMAC signatures, timestamp validation, origin validation, message sanitization, and replay attack prevention, closing Integration Gap #3 and Flow #2.

Purpose: Protect cross-tab coordination from message spoofing, replay attacks, cross-origin attacks, and data leakage by ensuring all messages are authenticated, validated, and sanitized.
Output: Tab coordination service with comprehensive message security applied to all BroadcastChannel communications.

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md

# Prior Phase Summaries
@.planning/phases/14-crosstab-security/14-01-SUMMARY.md
@.planning/phases/09-key-foundation/09-01-SUMMARY.md
@.planning/phases/12-keymanager-integration/12-01-SUMMARY.md

# Security Infrastructure
@js/security/message-security.js
@js/security/key-manager.js
@js/security/index.js

# Target Integration Point
@js/services/tab-coordination.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add message security to outgoing BroadcastChannel messages</name>
  <files>js/services/tab-coordination.js</files>
  <action>
Update js/services/tab-coordination.js to sign and sanitize outgoing messages:

1. **Import Security facade at top of file:**
   - Add: `import { Security } from '../security/index.js';`
   - Place after existing imports (around line 14)

2. **Modify sendMessage() function to sign messages:**
   - Locate sendMessage() function (around line 625)
   - Before calling coordinationTransport.postMessage(), add security wrapper
   - Add timestamp if not present: `if (!msg.timestamp) msg.timestamp = Date.now();`
   - Sanitize message to remove sensitive data: `const sanitizedMsg = Security.MessageSecurity.sanitizeMessage(msg);`
   - Get signing key and sign message:
     ```javascript
     const signingKey = await Security.getSigningKey();
     const signature = await Security.MessageSecurity.signMessage(sanitizedMsg, signingKey);
     ```
   - Add signature and origin to message:
     ```javascript
     const signedMessage = {
       ...sanitizedMsg,
       signature,
       origin: window.location.origin
     };
     ```
   - Send signed message: `coordinationTransport.postMessage(signedMessage);`
   - Handle signing errors gracefully with try/catch

3. **Update all direct coordinationTransport.postMessage calls:**
   - Find all direct calls to coordinationTransport.postMessage()
   - Replace them with sendMessage() calls OR add security wrapper inline
   - Ensure messages include timestamp, signature, and origin
   - Locations to update:
     - initWithBroadcastChannel() CANDIDATE message (line 478)
     - initWithBroadcastChannel() CLAIM_PRIMARY message (line 676)
     - initWithSharedWorker() CANDIDATE message (line 563)
     - initWithSharedWorker() CLAIM_PRIMARY message (line 581)
     - sendHeartbeat() function (line 931)
     - broadcastWatermark() function (line 1177)
     - broadcastSafeModeChange() function (line 1520)
     - initiateReElection() CANDIDATE message (line 869)

4. **Add nonce to each message for replay prevention:**
   - Generate nonce: `const nonce = `${TAB_ID}_${localSequence}_${Date.now()}`;`
   - Include nonce in message before signing
   - Nonce format must be consistent with MessageSecurity nonce tracking

5. **Code quality:**
   - Add error handling for signing failures
   - Log security violations but don't throw (avoid breaking coordination)
   - Use async/await consistently
   - Add JSDoc comments explaining security measures
   - Maintain backward compatibility with message format

Reference existing sendMessage() function around line 625.
  </action>
  <verify>
1. Security import added: grep "import.*Security.*from.*security" js/services/tab-coordination.js
2. sendMessage() function signs messages: grep -A10 "async function sendMessage" js/services/tab-coordination.js | grep -q "signMessage"
3. sendMessage() sanitizes messages: grep -A10 "async function sendMessage" js/services/tab-coordination.js | grep -q "sanitizeMessage"
4. Messages include signature: grep "signature:" js/services/tab-coordination.js
5. Messages include origin: grep "origin:.*window.location.origin" js/services/tab-coordination.js
6. Messages include timestamp: grep "timestamp:.*Date.now()" js/services/tab-coordination.js
7. Messages include nonce: grep "nonce:" js/services/tab-coordination.js
8. postMessage calls use signed messages: grep -B5 "postMessage" js/services/tab-coordination.js | grep -q "signature"
  </verify>
  <done>
All outgoing BroadcastChannel messages are signed with HMAC-SHA256, include timestamp and origin, are sanitized to remove sensitive data, include nonce for replay prevention, and signing errors are handled gracefully without breaking coordination.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add message verification to incoming BroadcastChannel messages</name>
  <files>js/services/tab-coordination.js</files>
  <action>
Update js/services/tab-coordination.js to verify and validate incoming messages:

1. **Modify createMessageHandler() to verify messages:**
   - Locate createMessageHandler() function (around line 637)
   - At the start of the handler, before switch statement, add verification pipeline

2. **Implement verification pipeline:**
   - Extract security fields from event.data:
     ```javascript
     const { signature, origin, timestamp, nonce, type, tabId } = event.data;
     ```
   - **Step 1: Origin validation (XTAB-03)**
     - Check if origin matches: `if (origin !== window.location.origin) { console.warn('Rejecting message from wrong origin:', origin); return; }`
   - **Step 2: Signature verification (XTAB-02)**
     - Get signing key: `const signingKey = await Security.getSigningKey();`
     - Verify signature: `const isValid = await Security.MessageSecurity.verifyMessage(event.data, signature, signingKey);`
     - Reject if invalid: `if (!isValid) { console.warn('Rejecting message with invalid signature'); return; }`
   - **Step 3: Timestamp validation (XTAB-06)**
     - Validate timestamp: `const isFresh = Security.MessageSecurity.validateTimestamp(event.data, 5);`
     - Reject if stale: `if (!isFresh) { console.warn('Rejecting stale message:', timestamp); return; }`
   - **Step 4: Nonce replay check (XTAB-05)**
     - Check nonce: `if (Security.MessageSecurity.isNonceUsed(nonce)) { console.warn('Rejecting replayed message:', nonce); return; }`
     - Mark nonce used: `Security.MessageSecurity.markNonceUsed(nonce);`

3. **Handle missing security fields:**
   - Messages without signature, origin, timestamp, or nonce should be rejected
   - Add defensive checks: `if (!signature || !origin || !timestamp || !nonce) { console.warn('Rejecting unsigned message'); return; }`

4. **Error handling:**
   - Wrap verification in try/catch
   - Log verification failures with context (message type, sender)
   - Never throw errors in message handler (breaks coordination)
   - Return early on verification failure

5. **Performance optimization:**
   - Perform fast checks first (origin, timestamp) before expensive crypto operations
   - Cache signing key to avoid repeated getSigningKey() calls
   - Sequence tracking should happen AFTER verification (don't track replayed messages)

6. **Code quality:**
   - Add JSDoc comments explaining verification pipeline
   - Log security violations for debugging
   - Maintain message ordering guarantees
   - Don't break existing message processing logic

Reference existing createMessageHandler() function around line 637.
  </action>
  <verify>
1. createMessageHandler has verification pipeline: grep -A20 "function createMessageHandler" js/services/tab-coordination.js | grep -q "verifyMessage"
2. Origin validation implemented: grep "origin.*!==.*window.location.origin" js/services/tab-coordination.js
3. Signature verification implemented: grep -A5 "verifyMessage" js/services/tab-coordination.js | grep -q "signingKey"
4. Timestamp validation implemented: grep -A5 "validateTimestamp" js/services/tab-coordination.js | grep -q "isFresh"
5. Nonce replay check implemented: grep -A5 "isNonceUsed" js/services/tab-coordination.js | grep -q "markNonceUsed"
6. Missing field checks: grep "if.*!signature.*!origin.*!timestamp.*!nonce" js/services/tab-coordination.js
7. Verification failures logged: grep "console.warn.*Rejecting message" js/services/tab-coordination.js
8. Verification happens before message processing: grep -A30 "function createMessageHandler" js/services/tab-coordination.js | grep -B5 "switch (type)" | grep -q "verify"
  </verify>
  <done>
All incoming BroadcastChannel messages are verified with HMAC signature, validated for origin matching window.location.origin, validated for timestamp (rejecting messages older than 5 seconds), and checked for nonce replay attacks, with verification failures logged but not breaking coordination.
  </done>
</task>

</tasks>

<verification>
After task completion, verify:
1. All outgoing messages signed: Open DevTools Console, log before/after sendMessage() to see signature added
2. All incoming messages verified: Add console.log in createMessageHandler to see verification pipeline
3. Origin validation works: Test with cross-origin iframe (should reject messages)
4. Timestamp validation works: Simulate old message by setting timestamp to Date.now() - 10000 (should reject)
5. Nonce replay prevention works: Send two messages with same nonce (second should be rejected)
6. Coordination still works: Open two tabs, verify primary/secondary election works
7. Fails gracefully: Intentionally break signature, verify coordination continues with warning
</verification>

<success_criteria>
1. All outgoing BroadcastChannel messages include HMAC-SHA256 signature
2. All outgoing messages include timestamp (Date.now())
3. All outgoing messages include origin (window.location.origin)
4. All outgoing messages are sanitized (sensitive fields removed)
5. All outgoing messages include nonce for replay prevention
6. All incoming messages have signature verified before processing
7. All incoming messages have origin validated
8. All incoming messages have timestamp validated (max 5 seconds old)
9. All incoming messages have nonce checked for replay attacks
10. Messages failing verification are rejected and logged
11. Verification failures don't break coordination system
12. Tab coordination continues to work correctly with security enabled
</success_criteria>

<output>
After completion, create `.planning/phases/14-crosstab-security/14-02-SUMMARY.md`
</output>

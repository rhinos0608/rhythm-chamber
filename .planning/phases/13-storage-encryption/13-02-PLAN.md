---
phase: 13-storage-encryption
plan: 02
type: execute
wave: 2
depends_on: [13-01]
files_modified:
  - js/security/storage-encryption.js
  - js/storage/config-api.js
autonomous: true
user_setup: []

must_haves:
  truths:
    - "StorageEncryption can classify data by sensitivity"
    - "API keys are automatically identified as sensitive"
    - "Chat history is automatically identified as sensitive"
    - "ConfigAPI encrypts sensitive data before storage"
    - "ConfigAPI decrypts sensitive data after retrieval"
    - "Non-sensitive data passes through unchanged"
  artifacts:
    - path: "js/security/storage-encryption.js"
      provides: "Data classification logic"
      contains: "shouldEncrypt"
      exports: ["shouldEncrypt"]
    - path: "js/storage/config-api.js"
      provides: "Transparent encryption integration"
      contains: ["Security.StorageEncryption.encrypt", "Security.StorageEncryption.decrypt"]
      modifies: ["setConfig", "getConfig"]
  key_links:
    - from: "ConfigAPI.setConfig"
      to: "StorageEncryption.shouldEncrypt"
      via: "classification check"
      pattern: "shouldEncrypt.*key.*value"
    - from: "ConfigAPI.setConfig"
      to: "Security.getDataEncryptionKey"
      via: "KeyManager integration"
      pattern: "Security\\.getDataEncryptionKey"
    - from: "ConfigAPI.setConfig"
      to: "StorageEncryption.encrypt"
      via: "encryption operation"
      pattern: "StorageEncryption\\.encrypt"
    - from: "ConfigAPI.getConfig"
      to: "StorageEncryption.decrypt"
      via: "decryption operation"
      pattern: "StorageEncryption\\.decrypt"
---

# Phase 13 Plan 02: Data Classification and ConfigAPI Integration

**Objective:** Implement data classification logic to identify sensitive data (API keys, chat history) and integrate transparent encryption/decryption into ConfigAPI's setConfig/getConfig operations.

Purpose: Automatically protect sensitive data by encrypting it before storage in IndexedDB and decrypting it after retrieval, with transparent encryption that doesn't require changes to existing ConfigAPI callers.
Output: StorageEncryption with shouldEncrypt() method, ConfigAPI with automatic encryption/decryption wrappers.

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-storage-encryption/13-RESEARCH.md

# Prior Plans
@.planning/phases/13-storage-encryption/13-01-PLAN.md

# Existing ConfigAPI
@js/storage/config-api.js

# Security Infrastructure
@js/security/index.js
@js/security/key-manager.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement data classification in StorageEncryption</name>
  <files>js/security/storage-encryption.js</files>
  <action>
Add data classification logic to StorageEncryption module:

1. **Add SENSITIVE_PATTERNS constant:**
   - Create array of sensitive key patterns at module level
   - Include: 'openrouter.apiKey', 'gemini.apiKey', 'claude.apiKey'
   - Add comment pattern for future LLM providers
   - Place near top of module after imports

2. **Implement shouldEncrypt(key, value) function:**
   - Export as standalone function (not part of StorageEncryption object)
   - Check if key matches any SENSITIVE_PATTERNS using Array.some()
   - Check if key starts with 'chat_' or contains 'chat' for chat history
   - Check if value is string matching API key patterns:
     * OpenRouter: starts with 'sk-or-v1-'
     * Gemini: starts with 'AIzaSy'
     * Claude: starts with 'sk-ant-'
   - Return true if any condition matches, false otherwise
   - Include comprehensive JSDoc with examples

3. **Code quality:**
   - Add inline comments explaining each classification rule
   - Include security rationale for each pattern
   - Use defensive coding (handle null/undefined values)
   - Follow OWASP guidelines for secrets identification

Reference implementation from 13-RESEARCH.md lines 384-416.

Do NOT implement:
- Key rotation migration
- Secure deletion
Keep focused on data classification only.
  </action>
  <verify>
1. SENSITIVE_PATTERNS exists: grep "SENSITIVE_PATTERNS" js/security/storage-encryption.js
2. shouldEncrypt function exists: grep "function shouldEncrypt\|export.*shouldEncrypt" js/security/storage-encryption.js
3. Checks key patterns: grep -E "openrouter\.apiKey|gemini\.apiKey|chat_" js/security/storage-encryption.js
4. Checks API key patterns: grep -E "sk-or-v1-|AIzaSy|sk-ant-" js/security/storage-encryption.js
5. Function is exported: grep "export.*shouldEncrypt" js/security/storage-encryption.js
  </verify>
  <done>
StorageEncryption.can classify sensitive data by key names and value patterns, identifying API keys and chat history for encryption.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate encryption into ConfigAPI.setConfig</name>
  <files>js/storage/config-api.js</files>
  <action>
Modify ConfigAPI.setConfig to encrypt sensitive data before storage:

1. **Import dependencies:**
   - Add import: `import { Security } from '../security/index.js';`
   - Add import: `import { shouldEncrypt } from '../security/storage-encryption.js';`
   - Place at top of file after existing imports

2. **Modify setConfig function:**
   - Before storing value, call shouldEncrypt(key, value)
   - If shouldEncrypt returns true:
     * Get encryption key: await Security.getDataEncryptionKey()
     * Encrypt value: await Security.StorageEncryption.encrypt(JSON.stringify(value), encKey)
     * Wrap encrypted value in metadata object:
       ```javascript
       valueToStore = {
         encrypted: true,
         keyVersion: 1,
         value: encrypted
       }
       ```
   - If shouldEncrypt returns false:
     * Use original value unchanged
   - Store valueToStore in IndexedDB instead of raw value
   - Maintain existing fallback to localStorage for non-encrypted data only

3. **Error handling:**
   - Wrap encryption operations in try/catch
   - On encryption failure, fall back to plaintext storage with console.warn
   - Log specific encryption errors for debugging
   - Never block config write due to encryption failure

4. **Backward compatibility:**
   - Check if record already has encrypted flag before re-encrypting
   - Handle mixed encrypted/plaintext scenarios gracefully
   - Maintain existing localStorage fallback behavior

5. **Code quality:**
   - Add JSDoc comment explaining encryption behavior
   - Include inline comments for encryption flow
   - Follow existing error handling patterns

Reference implementation from 13-RESEARCH.md lines 270-316.

Do NOT modify getConfig or removeConfig in this task - those are in Task 3.
  </action>
  <verify>
1. Imports Security: grep "import.*Security.*from.*security" js/storage/config-api.js
2. Imports shouldEncrypt: grep "import.*shouldEncrypt.*from.*storage-encryption" js/storage/config-api.js
3. Calls shouldEncrypt: grep "shouldEncrypt" js/storage/config-api.js
4. Calls getDataEncryptionKey: grep "getDataEncryptionKey" js/storage/config-api.js
5. Calls encrypt: grep "StorageEncryption\.encrypt" js/storage/config-api.js
6. Wraps encrypted data: grep -E "encrypted.*true|keyVersion" js/storage/config-api.js
7. No syntax errors: node -c js/storage/config-api.js
  </verify>
  <done>
ConfigAPI.setConfig automatically encrypts sensitive data (API keys, chat history) before storage, transparent to callers.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate decryption into ConfigAPI.getConfig</name>
  <files>js/storage/config-api.js</files>
  <action>
Modify ConfigAPI.getConfig to decrypt encrypted data after retrieval:

1. **Modify getConfig function:**
   - After retrieving result from IndexedDB
   - Check if result.value exists and result.value.encrypted === true
   - If encrypted flag is true:
     * Get encryption key: await Security.getDataEncryptionKey()
     * Decrypt value: await Security.StorageEncryption.decrypt(result.value.value, encKey)
     * If decryption returns non-null: Parse JSON and return
     * If decryption returns null: Return defaultValue (decryption failed)
   - If encrypted flag is false/missing:
     * Return result.value unchanged (backward compatibility)

2. **Error handling:**
   - Wrap decryption operations in try/catch
   - On decryption failure, return defaultValue
   - Log specific decryption errors for debugging
   - Never throw exceptions to callers - graceful degradation

3. **Backward compatibility:**
   - Handle missing encrypted flag (assume plaintext)
   - Handle malformed encrypted data gracefully
   - Support mixed encrypted/plaintext database state
   - Maintain localStorage fallback unchanged

4. **Code quality:**
   - Add JSDoc comment explaining decryption behavior
   - Include inline comments for decryption flow
   - Follow existing error handling patterns
   - Match setConfig encryption logic structure

Reference implementation from 13-RESEARCH.md lines 318-354.

Do NOT modify removeConfig in this task - that's in Plan 04.
  </action>
  <verify>
1. Checks encrypted flag: grep -E "encrypted.*true|result\.value\.encrypted" js/storage/config-api.js
2. Calls getDataEncryptionKey in getConfig: grep "getDataEncryptionKey" js/storage/config-api.js | wc -l (should be 2+)
3. Calls decrypt: grep "StorageEncryption\.decrypt" js/storage/config-api.js
4. Handles decryption failure: grep -A5 "decrypt" js/storage/config-api.js | grep -E "defaultValue|null"
5. No syntax errors: node -c js/storage/config-api.js
  </verify>
  <done>
ConfigAPI.getConfig automatically decrypts encrypted data after retrieval, transparent to callers.
  </done>
</task>

</tasks>

<verification>
After task completion, verify:
1. Data classification works: In browser, shouldEncrypt('openrouter.apiKey', 'sk-or-v1-test') === true
2. Encryption flow works: setConfig with API key stores encrypted data (check IndexedDB)
3. Decryption flow works: getConfig retrieves and decrypts correctly
4. Non-sensitive data unchanged: setConfig with normal key stores plaintext
5. Backward compatibility: Plaintext records still readable
6. Error handling: Invalid decryption returns defaultValue, not exceptions
</verification>

<success_criteria>
1. StorageEncryption exports shouldEncrypt() function
2. shouldEncrypt() identifies API keys by key name patterns
3. shouldEncrypt() identifies chat history by key name patterns
4. shouldEncrypt() identifies API keys by value patterns (sk-or-v1-, AIzaSy, sk-ant-)
5. ConfigAPI.setConfig encrypts sensitive data before IndexedDB storage
6. ConfigAPI.setConfig stores encrypted data with metadata wrapper (encrypted, keyVersion, value)
7. ConfigAPI.getConfig decrypts encrypted data after retrieval
8. ConfigAPI.getConfig handles mixed encrypted/plaintext database state
9. Encryption/decryption is transparent to existing callers
10. Non-sensitive data passes through unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/13-storage-encryption/13-02-SUMMARY.md`
</output>
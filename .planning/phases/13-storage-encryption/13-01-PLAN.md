---
phase: 13-storage-encryption
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - js/security/storage-encryption.js
  - js/security/index.js
autonomous: true
user_setup: []

must_haves:
  truths:
    - "StorageEncryption module can encrypt data using AES-GCM-256"
    - "StorageEncryption module can decrypt AES-GCM-256 encrypted data"
    - "Each encryption operation uses a unique IV"
    - "IV is stored alongside ciphertext for decryption"
    - "Encryption uses non-extractable key from KeyManager"
  artifacts:
    - path: "js/security/storage-encryption.js"
      provides: "AES-GCM-256 encryption/decryption operations"
      min_lines: 150
      contains: ["encrypt(", "decrypt(", "encryptData(", "decryptData("]
      exports: ["StorageEncryption"]
    - path: "js/security/index.js"
      provides: "Security facade export for StorageEncryption"
      contains: "StorageEncryption"
  key_links:
    - from: "StorageEncryption.encrypt()"
      to: "crypto.subtle.encrypt"
      via: "Web Crypto API"
      pattern: "crypto\\.subtle\\.encrypt.*AES-GCM"
    - from: "StorageEncryption.encrypt()"
      to: "Security.getDataEncryptionKey"
      via: "KeyManager integration"
      pattern: "getDataEncryptionKey"
    - from: "StorageEncryption.decrypt()"
      to: "crypto.subtle.decrypt"
      via: "Web Crypto API"
      pattern: "crypto\\.subtle\\.decrypt.*AES-GCM"
    - from: "js/security/index.js"
      to: "js/security/storage-encryption.js"
      via: "module import and export"
      pattern: "import.*StorageEncryption.*from.*storage-encryption"
---

# Phase 13 Plan 01: Create StorageEncryption Module

**Objective:** Create a StorageEncryption module that provides AES-GCM-256 encryption/decryption operations using KeyManager's non-extractable data encryption key, establishing the foundation for encrypting sensitive data at rest.

Purpose: Implement the core cryptographic operations needed to encrypt API keys and chat history before storing them in IndexedDB, using industry-standard AES-GCM-256 with unique IVs per operation.
Output: StorageEncryption module with encrypt/decrypt methods integrated into Security facade.

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-storage-encryption/13-RESEARCH.md

# Prior Phase Summary
@.planning/phases/12-keymanager-integration/12-01-SUMMARY.md
@.planning/phases/09-key-foundation/09-01-SUMMARY.md
@.planning/phases/09-key-foundation/09-02-SUMMARY.md

# Existing Security Infrastructure
@js/security/key-manager.js
@js/security/encryption.js
@js/security/index.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StorageEncryption module with AES-GCM-256 operations</name>
  <files>js/security/storage-encryption.js</files>
  <action>
Create js/security/storage-encryption.js with the following implementation:

1. **Module structure:**
   - Create as ES6 module: `export const StorageEncryption = { ... }`
   - Import Security facade for key access
   - Use AES-GCM-256 algorithm with 96-bit IV (12 bytes)

2. **encrypt(data, key) method:**
   - Accept plaintext data (string) and CryptoKey from KeyManager
   - Generate cryptographically random IV using crypto.getRandomValues(new Uint8Array(12))
   - Use TextEncoder to convert string to Uint8Array
   - Call crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, encodedData)
   - Combine IV + ciphertext into single Uint8Array
   - Return base64-encoded string using btoa(String.fromCharCode(...combined))
   - Include error handling with try/catch

3. **decrypt(encryptedData, key) method:**
   - Accept base64-encoded encrypted data and CryptoKey from KeyManager
   - Decode base64 to Uint8Array using atob and charCodeAt mapping
   - Extract IV (first 12 bytes) and ciphertext (remaining bytes)
   - Call crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, ciphertext)
   - Use TextDecoder to convert decrypted Uint8Array to string
   - Return decrypted string or null on failure
   - Include error handling that logs errors but returns null (graceful degradation)

4. **Code quality:**
   - Add comprehensive JSDoc comments for all methods
   - Include parameter types and return types
   - Add usage examples in comments
   - Include security notes about IV uniqueness
   - Follow existing code style from key-manager.js
   - Use async/await throughout

Reference implementation from 13-RESEARCH.md lines 214-266.

Do NOT implement:
- Data classification (shouldEncrypt) - will be in Plan 02
- Key rotation (migrateData) - will be in Plan 03
- Secure deletion (secureDelete) - will be in Plan 04
- ConfigAPI integration - will be in Plan 02

Keep this module focused ONLY on core encryption/decryption operations.
  </action>
  <verify>
1. File exists: ls -la js/security/storage-encryption.js
2. Module exports StorageEncryption: grep "export const StorageEncryption" js/security/storage-encryption.js
3. Contains encrypt method: grep "async encrypt" js/security/storage-encryption.js
4. Contains decrypt method: grep "async decrypt" js/security/storage-encryption.js
5. Uses AES-GCM: grep -i "AES-GCM" js/security/storage-encryption.js
6. Uses crypto.getRandomValues for IV: grep "getRandomValues" js/security/storage-encryption.js
7. File has reasonable size (150+ lines): wc -l js/security/storage-encryption.js
  </verify>
  <done>
StorageEncryption module created with AES-GCM-256 encrypt/decrypt operations using unique IV per encryption, IV stored with ciphertext, ready for integration with KeyManager.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate StorageEncryption into Security facade</name>
  <files>js/security/index.js</files>
  <action>
Update js/security/index.js to export StorageEncryption:

1. **Import StorageEncryption module:**
   - Add import at top of file: `import * as StorageEncryption from './storage-encryption.js';`
   - Place after other security module imports (around line 13)

2. **Export StorageEncryption through Security facade:**
   - Add to exports object (around line 360+): `StorageEncryption`
   - Place in logical grouping with other security modules
   - Add JSDoc comment explaining it provides AES-GCM-256 storage encryption

3. **Update KeyManager exports section JSDoc:**
   - Extend existing KeyManager documentation (around lines 345-360)
   - Add note that StorageEncryption uses KeyManager.getDataEncryptionKey()
   - Reference the integration pattern

4. **Maintain backward compatibility:**
   - Do NOT modify existing exports
   - Do NOT change existing API contracts
   - Only add new export, no breaking changes

5. **Code quality:**
   - Follow existing documentation style
   - Use consistent JSDoc format
   - Include usage guidance in comments

Reference pattern from existing KeyManager exports in lines 345-360.
  </action>
  <verify>
1. Import statement exists: grep "import.*storage-encryption" js/security/index.js
2. Export exists: grep "StorageEncryption" js/security/index.js | grep -v "^import"
3. JSDoc documentation added: grep -B2 "StorageEncryption" js/security/index.js | grep -q "\/\*\*"
4. Module structure intact: node -c js/security/index.js (no syntax errors)
  </verify>
  <done>
StorageEncryption exported through Security facade, accessible via Security.StorageEncryption.encrypt() and Security.StorageEncryption.decrypt(), ready for ConfigAPI integration.
  </done>
</task>

</tasks>

<verification>
After task completion, verify:
1. StorageEncryption module can be imported: node -e "import('./js/security/storage-encryption.js').then(m => console.log('Module loaded:', !!m.StorageEncryption))"
2. Security facade exports StorageEncryption: In browser console, typeof Security.StorageEncryption === 'object'
3. Module has required methods: typeof Security.StorageEncryption.encrypt === 'function' && typeof Security.StorageEncryption.decrypt === 'function'
4. Module uses Web Crypto API patterns consistent with research
</verification>

<success_criteria>
1. StorageEncryption module created with AES-GCM-256 encrypt/decrypt operations
2. Each encryption generates unique 96-bit IV using crypto.getRandomValues
3. IV is prepended to ciphertext for storage during encryption
4. Decryption extracts IV from first 12 bytes before decrypting
5. Module exported through Security facade as Security.StorageEncryption
6. Module designed to use KeyManager.getDataEncryptionKey() (called by consumers)
7. Code follows existing patterns from key-manager.js and encryption.js
8. Comprehensive JSDoc documentation included
</success_criteria>

<output>
After completion, create `.planning/phases/13-storage-encryption/13-01-SUMMARY.md`
</output>
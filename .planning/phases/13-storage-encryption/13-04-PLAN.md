---
phase: 13-storage-encryption
plan: 04
type: execute
wave: 4
depends_on: [13-02]
files_modified:
  - js/security/storage-encryption.js
  - js/storage/config-api.js
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Encrypted data is overwritten before deletion from IndexedDB"
    - "Secure deletion uses random data to overwrite encrypted values"
    - "ConfigAPI.removeConfig uses secure deletion for encrypted data"
    - "Plaintext data uses standard deletion (no overwriting needed)"
    - "Secure deletion failures fall back to standard deletion"
  artifacts:
    - path: "js/security/storage-encryption.js"
      provides: "Secure deletion implementation"
      contains: "secureDelete"
      exports: ["secureDelete"]
    - path: "js/storage/config-api.js"
      provides: "Secure deletion integration"
      contains: "secureDelete"
      modifies: ["removeConfig"]
  key_links:
    - from: "ConfigAPI.removeConfig"
      to: "IndexedDBCore.get"
      via: "fetch record before deletion"
      pattern: "IndexedDBCore\.get.*removeConfig"
    - from: "ConfigAPI.removeConfig"
      to: "StorageEncryption.secureDelete"
      via: "secure deletion for encrypted data"
      pattern: "secureDelete"
    - from: "secureDelete"
      to: "crypto.getRandomValues"
      via: "generate random overwrite data"
      pattern: "getRandomValues"
    - from: "secureDelete"
      to: "IndexedDBCore.put"
      via: "overwrite with random data"
      pattern: "put.*random"
    - from: "secureDelete"
      to: "IndexedDBCore.delete"
      via: "delete after overwrite"
      pattern: "delete"
---

# Phase 13 Plan 04: Secure Deletion Implementation

**Objective:** Implement secure deletion for encrypted data by overwriting with random data before removal from IndexedDB, preventing recovery of sensitive information.

Purpose: When deleting encrypted API keys or chat history, overwrite the encrypted values with random data before deletion to prevent forensic recovery, following secure data sanitization best practices.
Output: StorageEncryption.secureDelete() method, ConfigAPI.removeConfig() integration for encrypted data.

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-storage-encryption/13-RESEARCH.md

# Prior Plans
@.planning/phases/13-storage-encryption/13-01-PLAN.md
@.planning/phases/13-storage-encryption/13-02-PLAN.md

# Existing Infrastructure
@js/storage/config-api.js
@js/storage/indexeddb.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement secure deletion in StorageEncryption</name>
  <files>js/security/storage-encryption.js</files>
  <action>
Add secure deletion logic to StorageEncryption module:

1. **Implement secureDelete(storeName, key) function:**
   - Export as standalone async function
   - Import IndexedDBCore (or accept as parameter)
   - Fetch record: await IndexedDBCore.get(storeName, key)
   - If record doesn't exist, return immediately (nothing to delete)
   - Check if record.value?.encrypted === true
   - If encrypted:
     * Calculate length of encrypted value string
     * Generate random data: crypto.getRandomValues(new Uint8Array(length))
     * Convert to base64: btoa(String.fromCharCode(...randomData))
     * Overwrite record: await IndexedDBCore.put(storeName, { key, value: randomBase64 })
     * Then delete: await IndexedDBCore.delete(storeName, key)
   - If not encrypted:
     * Skip overwriting, just delete
     * await IndexedDBCore.delete(storeName, key)

2. **Error handling:**
   - Wrap entire operation in try/catch
   - On overwrite failure, log warning and proceed to delete
   - On delete failure, log error
   - Never throw exceptions - graceful degradation
   - Log specific failures for debugging

3. **Add JSDoc documentation:**
   - Explain purpose: prevent data recovery of encrypted records
   - Document parameters: storeName, key
   - Document behavior: overwrite with random data then delete
   - Include security note: only overwrites encrypted data
   - Add usage example

4. **Code quality:**
   - Follow existing error handling patterns
   - Include inline comments explaining each step
   - Use defensive coding (handle missing records)
   - Log operations for debugging

Reference implementation from 13-RESEARCH.md lines 132-153.

Do NOT implement:
- Integration with ConfigAPI.removeConfig (Task 2)
Keep focused on secure deletion logic only.
  </action>
  <verify>
1. secureDelete function exists: grep "function secureDelete\|export.*secureDelete" js/security/storage-encryption.js
2. Fetches record before deletion: grep -A5 "secureDelete" js/security/storage-encryption.js | grep "IndexedDBCore\.get"
3. Checks encrypted flag: grep -A10 "secureDelete" js/security/storage-encryption.js | grep -E "encrypted.*true"
4. Generates random data: grep -A15 "secureDelete" js/security/storage-encryption.js | grep "getRandomValues"
5. Overwrites before delete: grep -A20 "secureDelete" js/security/storage-encryption.js | grep -E "put.*delete"
6. Has error handling: grep -A5 "secureDelete" js/security/storage-encryption.js | grep -E "try|catch"
  </verify>
  <done>
StorageEncryption.secureDelete() can overwrite encrypted data with random values before deletion from IndexedDB.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate secure deletion into ConfigAPI.removeConfig</name>
  <files>js/storage/config-api.js</files>
  <action>
Modify ConfigAPI.removeConfig to use secure deletion for encrypted data:

1. **Import secureDelete function:**
   - Add import: `import { secureDelete } from '../security/storage-encryption.js';`
   - Place at top of file after other storage-encryption imports

2. **Modify removeConfig function:**
   - Before calling IndexedDBCore.delete()
   - Fetch record to check encryption status: await IndexedDBCore.get(IndexedDBCore.STORES.CONFIG, key)
   - Check if result?.value?.encrypted === true
   - If encrypted:
     * Call secureDelete(IndexedDBCore.STORES.CONFIG, key)
     * Secure delete handles overwrite + delete internally
   - If not encrypted:
     * Use standard deletion: await IndexedDBCore.delete(IndexedDBCore.STORES.CONFIG, key)
   - Also clean from localStorage (existing behavior)

3. **Error handling:**
   - Wrap secure deletion in try/catch
   - On secureDelete failure, fall back to standard delete
   * Log warning about fallback behavior
   - Maintain existing localStorage cleanup

4. **Backward compatibility:**
   - Handle missing records gracefully (no error if doesn't exist)
   - Handle malformed encrypted data (fall back to standard delete)
   - Maintain existing localStorage cleanup behavior

5. **Code quality:**
   - Add JSDoc comment explaining secure deletion behavior
   - Include inline comments for deletion flow
   - Follow existing error handling patterns
   - Match encryption integration style from setConfig/getConfig

Do NOT modify other ConfigAPI methods - only removeConfig.
  </action>
  <verify>
1. Imports secureDelete: grep "import.*secureDelete.*from.*storage-encryption" js/storage/config-api.js
2. Fetches record before deletion: grep -A5 "removeConfig" js/storage/config-api.js | grep "IndexedDBCore\.get"
3. Checks encrypted flag: grep -A10 "removeConfig" js/storage/config-api.js | grep -E "encrypted.*true"
4. Calls secureDelete: grep "secureDelete" js/storage/config-api.js
5. Has fallback to standard delete: grep -A15 "removeConfig" js/storage/config-api.js | grep -E "catch.*delete"
6. No syntax errors: node -c js/storage/config-api.js
  </verify>
  <done>
ConfigAPI.removeConfig automatically uses secure deletion for encrypted data, overwriting with random data before removal.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add encryption integration tests</name>
  <files>tests/integration/storage-encryption-test.js</files>
  <action>
Create integration test for storage encryption:

1. **Create test file:**
   - Create tests/integration/storage-encryption-test.js
   - Structure as browser-based test (uses Web Crypto API)
   - Include comprehensive test coverage

2. **Test cases:**
   - **Test 1: Encrypt/decrypt roundtrip**
     * Encrypt test data with StorageEncryption.encrypt()
     * Decrypt result with StorageEncryption.decrypt()
     * Verify original data matches decrypted data
   - **Test 2: IV uniqueness**
     * Encrypt same data twice
     * Verify ciphertexts are different (unique IVs)
   - **Test 3: Data classification**
     * Test shouldEncrypt() with API key patterns
     * Test shouldEncrypt() with chat history patterns
     * Test shouldEncrypt() with non-sensitive data
   - **Test 4: ConfigAPI integration**
     * Set sensitive config via ConfigAPI.setConfig()
     * Retrieve via ConfigAPI.getConfig()
     * Verify data matches (transparent encryption)
     * Check IndexedDB stores encrypted data (not plaintext)
   - **Test 5: Migration**
     * Create plaintext sensitive record
     * Run ConfigAPI.migrateToEncryptedStorage()
     * Verify record is now encrypted
   - **Test 6: Secure deletion**
     * Create encrypted record
     * Delete via ConfigAPI.removeConfig()
     * Verify record is removed
     * (Note: can't easily test overwrite without IndexedDB inspection tools)

3. **Test structure:**
   - Use console.log for test output
   - Include test harness for running all tests
   - Provide instructions for running in browser DevTools
   - Include expected output in comments

4. **Code quality:**
   - Follow existing test patterns from keymanager-browser-test.js
   - Include clear test names and descriptions
   - Use async/await throughout
   - Include error handling

This is a verification task - creates test infrastructure for manual or automated verification.
  </action>
  <verify>
1. Test file created: ls -la tests/integration/storage-encryption-test.js
2. Contains encrypt/decrypt test: grep "encrypt\|decrypt" tests/integration/storage-encryption-test.js
3. Contains IV uniqueness test: grep "unique\|IV\|ciphertext" tests/integration/storage-encryption-test.js
4. Contains data classification test: grep "shouldEncrypt" tests/integration/storage-encryption-test.js
5. Contains ConfigAPI integration test: grep "ConfigAPI\|setConfig\|getConfig" tests/integration/storage-encryption-test.js
6. Contains migration test: grep "migrate" tests/integration/storage-encryption-test.js
7. Contains secure deletion test: grep "secureDelete\|removeConfig" tests/integration/storage-encryption-test.js
8. Test has instructions: grep -E "console|DevTools|run" tests/integration/storage-encryption-test.js
  </verify>
  <done>
Integration test suite created for storage encryption, covering encrypt/decrypt, IV uniqueness, data classification, ConfigAPI integration, migration, and secure deletion.
  </done>
</task>

</tasks>

<verification>
After task completion, verify:
1. Secure deletion works: Encrypted record is overwritten before deletion
2. Standard deletion unchanged: Plaintext records use standard delete
3. ConfigAPI.removeConfig integration: Calls secureDelete for encrypted data
4. Error handling: Falls back to standard delete on secureDelete failure
5. Integration tests pass: All test cases produce expected output
6. Browser compatibility: Tests run in browser DevTools console
</verification>

<success_criteria>
1. StorageEncryption.secureDelete() accepts storeName and key
2. secureDelete() fetches record to check encryption status
3. secureDelete() generates random data matching encrypted value length
4. secureDelete() overwrites encrypted record with random data
5. secureDelete() deletes record after overwrite
6. secureDelete() only overwrites if encrypted flag is true
7. ConfigAPI.removeConfig() calls secureDelete() for encrypted data
8. ConfigAPI.removeConfig() uses standard delete for plaintext data
9. Integration tests cover all major encryption workflows
10. Tests can be run in browser DevTools for verification
</success_criteria>

<output>
After completion, create `.planning/phases/13-storage-encryption/13-04-SUMMARY.md`
</output>